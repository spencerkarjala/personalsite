<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Grid Pathfinding in Unreal Engine | skarja.la</title>
        <link rel="stylesheet" href="/styles.css" />
    </head>
    <body id="root-container" class="root-container">
        <div class="document-content-container">
            <div class="project-page-container">
                <div class="header-container">
                    <div class="header-title">
                        <a href="/" class="invisilink">
                            <div class="header-name">
                                skarjala
                            </div>
                        </a>
                        <div class="header-spacer">•</div>
                        <div class="header-contact">
                            spencerkarjala@gmail.com
                        </div>
                    </div>
                    <hr style="width:100%; height:0;" />
                    <div class="nav-container">
                        <a class="nav-item" href="/about/">About</a>
                        <a class="nav-item" href="/projects/">Projects</a>
                    </div>
                </div>

                <div class="project-page-content">
                    <ol>
                        <li><a href="/projects/grid-pathfinding-ue5/01-project-overview/" class="generic-nocolor">Project Overview</a></li>
                        <li><a href="/projects/grid-pathfinding-ue5/02-exploring-unreal-navigation/" class="generic-nocolor">Exploring Unreal Navigation</a></li>
                        <li><a href="/projects/grid-pathfinding-ue5/03-creating-unreal-interface/" class="generic-nocolor">Creating the Unreal Interface</a></li>
                        <li>Creating Navigation Data (WIP)</a></li>
                        <!-- <li><a href="/projects/grid-pathfinding-ue5/04-creating-navigation-data/" class="generic-nocolor">Creating Navigation Data</a></li> -->
                        <li>Implementing Pathfinding (WIP)</li>
                        <li>Creating the Cursor (WIP)</li>
                    </ol>

                    <div class="generic-spacer-medium"></div>

                    <h1>Exploring Unreal Navigation</h1>
                    <p>
                        To start, I found a <a class="generic-nocolor" target="_blank" href="https://unrealingens.wordpress.com/2018/05/02/overriding-default-ue4-pathfinding-behavior-through-recastnavmesh/">blog post</a>
                        by Nicholas Goldstein that outlines a process for hooking into <code>ARecastNavMesh</code>
                        to provide custom pathfinding without re-compiling the engine. The main notable things
                        about <code>ARecastNavMesh</code> to understand are:
                    </p>
                    <ol>
                        <li>It is an interface for the engine to use <a class="generic-nocolor" target="_blank" href="https://recastnav.com/">Recast</a> navigation</li>
                        <li>The Recast implementation is conveniently hidden behind a <a class="generic-nocolor" target="_blank" href="https://en.cppreference.com/w/cpp/language/pimpl">PImpl</a> pattern, meaning the implementation can be switched out</li>
                        <li>The <code>FindPath</code> function is actually a function pointer that can be swapped with a custom implementation</li>
                    </ol>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-600px" src="./recast-nav-mesh-overridables.png"></img>
                        <p class="project-image-subtitle">ARecastNavMesh constructor providing default pathfinding implementations</p>
                    </div>
                    <p>
                        While this gives the insertion point for custom pathfinding logic, it doesn't provide
                        much information on creating and maintaining bounded map data. This is also where the
                        article ends, so we'll have to look more closely at the engine source code next.
                    </p>

                    <div class="generic-spacer-small"></div>
                    <h2>Navigation Bounds</h2>
                    <p>
                        In Unreal Engine, editor users place <code>NavMeshBoundVolume</code>s to specify the
                        areas of geometry that should be navigable. Thankfully, the source code for <code>NavMeshBoundVolume</code>
                        is relatively small — they're mainly used as a proxy to tell the navigation system that
                        its bounds have changed.
                    </p>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./nav-mesh-bounds-volume-post-edit-change-property.png"></img>
                        <p class="project-image-subtitle">PostEditChangeProperty in ANavMeshBoundsVolume.cpp</p>
                    </div>

                    <p>
                        Inside Unreal's navigation system, when <code>OnNavigationBoundsUpdated</code> is called,
                        <code>UNavigationSystemV1</code> queues an <code>FNavigationBoundsUpdateRequest</code> by
                        calling <code>AddNavigationBoundsUpdateRequest</code>. Then, on the next tick, the navigation
                        system services any available navigation bounds update requests.
                    </p>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./navsystem-enqueue-bounds-request.png"></img>
                        <p class="project-image-subtitle">UNavigationSystemV1 enqueueing and servicing a navigation bounds update request</p>
                    </div>

                    <p>
                        To update the navigation bounds, <code>PerformNavigationBoundsUpdate</code> does the following:
                    </p>
                    <ol type="1">
                        <li>For each nav bounds update request, depending on what type of request it is: add, update, or remove the nav bound from the navigation system</li>
                        <li>If any bounds were created, changed, or deleted in the previous step, notify all available <code>ANavigationData</code> instances</li>
                        <li>If navigation building is available, mark any updated nav bounds as 'dirty' to trigger a navigation build</li>
                    </ol>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./navsystem-handle-bounds-update.png"></img>
                        <p class="project-image-subtitle">UNavigationSystemV1 handling navigation bounds update requests (abridged)</p>
                    </div>

                    <p>
                        Steps 2 and 3 of this process are focused on building/rebuilding navigation data through the
                        <code>RebuildDirtyAreas</code> and <code>OnNavigationBoundsChanged</code> functions, which are 
                        both virtual within <code>ANavigationData</code> (the parent class of <code>ARecastNavMesh</code>).
                        A tempting solution is to override these functions, but it looks like Unreal offers a better way
                        forward.
                    </p>

                    <div class="generic-spacer-small"></div>
                    <h2>Building Navigation Data</h2>
                    <p>
                        Interestingly, <code>ARecastNavMesh</code> does not implement either <code>OnNavigationBoundsChanged</code>
                        or <code>RebuildDirtyAreas</code>. This means that it's using <code>ANavigationData</code>'s
                        default implementation, which implies that Unreal must have a way for <code>ARecastNavMesh</code>
                        to define how its builds are implemented. By looking at the base class functions, we can see that this is true:
                    </p>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./navdata-generation-code.png"></img>
                        <p class="project-image-subtitle">ANavigationData handling rebuilds on bounds changes</p>
                    </div>

                    <p>
                        It turns out that the <code>ANavigationData</code> class defines a pointer to an <code>FNavDataGenerator</code>
                        object that implements navigation data builds. This means that Unreal will <i>automatically call nav data builds for us</i>
                        if we implement an <code>FNavDataGenerator</code> and specify it in our custom <code>ARecastNavMesh</code>
                        implementation.
                    </p>
                    <p>
                        The main challenge with building navigation data from <code>FNavDataGenerator</code> is that it
                        will need to do lots of world queries at build time to create the tilemap. The engine code in 
                        <code>FRecastNavMeshGenerator</code> solves this by storing a reference to the <code>ARecastNavMesh</code>
                        that is associated with the generator. This isn't a perfect solution, since it means the generator class
                        can end up pretty tightly coupled to the nav data actor, but we will likely do the same since those
                        abstractions can be built later.
                    </p>
                </div>
            </div>
        </div>
    </body>
</html>
