<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Grid Pathfinding in Unreal Engine | skarja.la</title>
        <link rel="stylesheet" href="/styles.css" />
    </head>
    <body id="root-container" class="root-container">
        <div class="document-content-container">
            <div class="project-page-container">
                <div class="header-container">
                    <div class="header-title">
                        <a href="/" class="invisilink">
                            <div class="header-name">
                                skarjala
                            </div>
                        </a>
                        <div class="header-spacer">â€¢</div>
                        <div class="header-contact">
                            spencerkarjala@gmail.com
                        </div>
                    </div>
                    <hr style="width:100%; height:0;" />
                    <div class="nav-container">
                        <a class="nav-item" href="/about/">About</a>
                        <a class="nav-item" href="/projects/">Projects</a>
                    </div>
                </div>

                <div class="project-page-content">
                    <div class="generic-spacer-medium"></div>
                    <div class="projects-chapter-select" start='0'>
                        <div class="projects-chapter-select-row projects-chapter-select-secondary">
                            <div class="projects-chapter-select-left"></div>
                            <div class="projects-chapter-select-center"><a href="/projects/grid-pathfinding-ue5/" class="generic-nocolor">Index</a></div>
                            <div class="projects-chapter-select-right"></div>
                        </div>
                        <div class="projects-chapter-select-row projects-chapter-select-secondary">
                            <div class="projects-chapter-select-left"></div>
                            <div class="projects-chapter-select-center"><a href="/projects/grid-pathfinding-ue5/01-project-overview/" class="generic-nocolor">Project Overview</a></div>
                            <div class="projects-chapter-select-right"></div>
                        </div>
                        <div class="projects-chapter-select-row projects-chapter-select-secondary">
                            <div class="projects-chapter-select-left"></div>
                            <div class="projects-chapter-select-center"><a href="/projects/grid-pathfinding-ue5/02-exploring-unreal-navigation/" class="generic-nocolor">Exploring Unreal Navigation</a></div>
                            <div class="projects-chapter-select-right"></div>
                        </div>
                        <div class="projects-chapter-select-row projects-chapter-select-secondary">
                            <div class="projects-chapter-select-left"></div>
                            <div class="projects-chapter-select-center"><a href="/projects/grid-pathfinding-ue5/03-creating-unreal-interface/" class="generic-nocolor">Creating the Unreal Interface</a></div>
                            <div class="projects-chapter-select-right"></div>
                        </div>
                        <div class="projects-chapter-select-row projects-chapter-select-secondary">
                            <div class="projects-chapter-select-left"></div>
                            <div class="projects-chapter-select-center">Creating Navigation Data (WIP)</div>
                            <div class="projects-chapter-select-right"></div>
                        </div>
                        <div class="projects-chapter-select-row projects-chapter-select-secondary">
                            <div class="projects-chapter-select-left"></div>
                            <div class="projects-chapter-select-center">Implementing Pathfinding (WIP)</div>
                            <div class="projects-chapter-select-right"></div>
                        </div>
                        <div class="projects-chapter-select-row projects-chapter-select-primary">
                            <div class="projects-chapter-select-left"></div>
                            <div class="projects-chapter-select-center"><a href="/projects/grid-pathfinding-ue5/06-creating-cursor/" class="generic-nocolor">Creating the Cursor</a></div>
                            <div class="projects-chapter-select-right"></div>
                        </div>
                    </div>

                    <div class="generic-spacer-medium"></div>
                    <h1>Creating the Cursor</h1>
                    <p>
                        For this plugin, I'd like there to be an easy way to hook in a customizable cursor
                        that previews pathfinding results by tracing the path. Something like this:
                    </p>
                    <div class="generic-shrink-container-62p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-500px" src="./previewpath-idea.png"></img>
                    </div>
                    <p>
                        Since the path is always attached to the character, it would work as a SceneComponent
                        attached to the PlayerCharacter. Off the top of my head, a user would need to be able to:
                    </p>
                    <ol>
                        <li>Update the cursor destination</li>
                        <li>Set the cursor visibility</li>
                        <li>Customize the look of the cursor</li>
                    </ol>
                    <p>
                        For (1), if we raycast from the player's mouse position, then the hit result can be
                        used as the destination for the cursor. We would also need to pass in the normal
                        vector at that point so the cursor can match the slope of the ground. For now, it's
                        easiest to just let the cursor get the path from the MappingServer.
                    </p>
                    <p>
                        (2) is easy because the built-in <code>SetVisibility()</code> can be used.
                    </p>
                    <p>
                        (3) is more complex, since it's not immediately clear how the cursor is visually
                        represented. A static mesh can be used for the destination component, but what about
                        the path? After reading online for a while and trying a few things, it seems like
                        using <code>SplineMeshComponent</code>s will be quickest. It would be possible to
                        use a <code>ProceduralMeshComponent</code>, but manually building the mesh data
                        sounds time-consuming, and the implementation can be switched later if performance
                        is an issue.
                    </p>
                    <p>
                        That gives the following as the interface:
                    </p>
                    <div class="code-block-container elevated-project-content">
                        <div class="code-block">
                            <div class="code-block-line">void UpdatePosition(const FVector& Destination, const FVector& DestNormal);</div>
                            <div class="code-block-line">void SetDestinationMesh(const UStaticMesh* Mesh);</div>
                            <div class="code-block-line">void SetPathMesh(const UStaticMesh* Mesh);</div>
                        </div>
                    </div>
                    <p>
                        Updating the meshes is easy enough to implement, since it only requires updating
                        the corresponding components and the saved base mesh for the PathMesh.
                    </p>
                    <div class="code-block-container elevated-project-content">
                        <div class="code-block">
                            <div class="code-block-line">void SetDestinationMesh(const UStaticMesh* Mesh)</div>
                            <div class="code-block-line">{</div>
                            <div class="code-block-line">    check(DestinationMesh);</div>
                            <div class="code-block-line">    check(IsValid(Mesh));</div>
                            <div class="code-block-line">    DestinationMesh->SetStaticMesh(Mesh);</div>
                            <div class="code-block-line">}</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">void SetPathMesh(const UStaticMesh* Mesh)</div>
                            <div class="code-block-line">{</div>
                            <div class="code-block-line">    check(IsValid(Mesh));</div>
                            <div class="code-block-line">    PathMeshBase = Mesh;</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// loop over each premade SplineMeshComponent, updating their meshes</code-comment></div>
                            <div class="code-block-line">    for (const auto& PathMeshComponent : PathMeshComponents) {</div>
                            <div class="code-block-line">        check(PathMeshComponent);</div>
                            <div class="code-block-line">        PathMeshComponent->SetStaticMesh(PathMeshBase);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">}</div>
                        </div>
                    </div>

                    <div class="generic-spacer-small"></div>

                    <h2>Updating the cursor</h2>

                    <p>
                        At a high level, updating the cursor destination means:
                    </p>
                    <ol>
                        <li>Round the cursor destination to the grid</li>
                        <li>If cursor position hasn't changed, do nothing and return</li>
                        <li>Pathfind to the destination from the player's world position</li>
                        <li>If pathfinding fails, then the point is unreachable, so hide the cursor and return</li>
                        <li>Update <code>SplineMeshComponent</code>s to render the path on-screen</li>
                        <li>Update position of the <code>StaticMeshComponent</code> to the destination</li>
                        <li>Make the cursor visible</li>
                    </ol>
                    <p>
                        Most of this is hopefully self-explanatory as shown below. Step 5, however, is not
                        trivial, for a couple of reasons.
                    </p>

                    <div class="generic-spacer-small"></div>
                    <div class="code-block-container elevated-project-content">
                        <div class="code-block">
                            <div class="code-block-line">bool UGNCursorComponent::UpdatePosition(const FVector& WorldDestination, const FVector& DestNormal)</div>
                            <div class="code-block-line">{    </div>
                            <div class="code-block-line">    <code-comment>// 1. round destination to configured grid</code-comment></div>
                            <div class="code-block-line">    FVector DestinationRounded(</div>
                            <div class="code-block-line">        round(WorldDestination.X / GridSize) * GridSize</div>
                            <div class="code-block-line">        round(WorldDestination.Y / GridSize) * GridSize</div>
                            <div class="code-block-line">        WorldDestination.Z</div>
                            <div class="code-block-line">    );</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 2. exit early if cursor destination hasn't changed</code-comment></div>
                            <div class="code-block-line">    if ((DestinationRounded - CurrCursorLocation).Length() &lt; 2e-4) {</div>
                            <div class="code-block-line">        return true;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    const FVector& UpDir = FVector::UpVector;</div>
                            <div class="code-block-line">    FVector NormalDir = DestNormal;</div>
                            <div class="code-block-line">    NormalDir.Normalize();</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// hide cursor if floor slope at new dest. is too steep</code-comment></div>
                            <div class="code-block-line">    const double CosOfUpToNormalAngle = FVector::DotProduct(UpDir, NormalDir);</div>
                            <div class="code-block-line">    if (CosOfUpToNormalDir &lt;= CosOfMaxInclineAngle) {</div>
                            <div class="code-block-line">        SetVisibility(false);</div>
                            <div class="code-block-line">        return true;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 3. perform pathfinding</code-comment></div>
                            <div class="code-block-line">    const auto* OwnerActor = GetOwner();</div>
                            <div class="code-block-line">    if (!IsValid(OwnerActor)) {</div>
                            <div class="code-block-line">        UE_LOG(LogGNCursorComopnent, Error, TEXT("Failed to get OwnerActor"));</div>
                            <div class="code-block-line">        return false;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    const TArray&lt;FVector&gt; PathPoints = FMappingServer::GetInstance().FindPath(</div>
                            <div class="code-block-line">        OwnerActor->GetActorLocation(),</div>
                            <div class="code-block-line">        WorldDestination</div>
                            <div class="code-block-line">    );</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 4. hide cursor if destination is not reachable</code-comment></div>
                            <div class="code-block-line">    if (PathPoints.Num() &lt; 2) {</div>
                            <div class="code-block-line">        SetVisibility(false);</div>
                            <div class="code-block-line">        return true;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// rotate destination mesh if floor slope is too flat</code-comment></div>
                            <div class="code-block-line">    FRotator UpVecToNormalRotation;</div>
                            <div class="code-block-line">    if (CosOfUpToNormalAngle &lt; 1.0 - UE_KINDA_SMALL_NUMBER) {</div>
                            <div class="code-block-line">        UpVecToNormalRotation.Yaw = FMath::RadiansToDegrees(atan2(NormalDir.Y, NormalDir.X));</div>
                            <div class="code-block-line">        UpVecToNormalRotation.Pitch = FMath::RadiansToDegrees(-acos(CosOfUpToNormalAngle));</div>
                            <div class="code-block-line">        DestinationRounded.Z = floor(DestinationRounded.Z / 50.0) * 50.0 + 25.0;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 5. update meshes to display the path</code-comment></div>
                            <div class="code-block-line">    UpdatePath(PathPoints);</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 6. update destination mesh to show final point on path</code-comment></div>
                            <div class="code-block-line">    const auto LocalCursorDestinationPosition = DestinationRounded;</div>
                            <div class="code-block-line">    DestinationMeshComponent->SetRelativeLocation(LocalCursorDestinationPosition);</div>
                            <div class="code-block-line">    DestinationMeshComponent->SetWorldRotation(UpVecToNormalRotation);</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 7. save cursor state and make the cursor visible</code-comment></div>
                            <div class="code-block-line">    CurrCursorLocation = DestinationRounded;</div>
                            <div class="code-block-line">    SetVisibility(true);</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    return true;</div>
                            <div class="code-block-line">}</div>
                        </div>
                    </div>
                    <div class="generic-spacer-small"></div>

                    <p>
                        <b>Problem 1</b>: Because the number of points along the path is variable, the number
                        of splines needed to represent the path is also variable.
                    </p>
                    <p>
                        Specifically, if there are N points along the path, then there are N-1 <code>SplineMeshComponent</code>s
                        needed to display that path. This means that <code>SplineMeshComponent</code>s need to be
                        allocated to, connected to, disconnected from, and deleted from the cursor at runtime,
                        which sounds complicated and messy.
                    </p>
                    <div class="generic-shrink-container-62p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-500px" src="./previewpath-segments-example.png"></img>
                    </div>
                    <p>
                        Instead, a better approach is to pre-allocate a list of <code>SplineMeshComponent</code>s
                        that are shown and hidden at runtime. If the path needs more spline sections, more will
                        be allocated and connected to the cursor, but they will just be added to the pre-allocated
                        list and treated the same as the others.
                    </p>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./previewpath-list-spline-idea.png"></img>
                    </div>

                    <p>
                        <b>Problem 2</b>: The ends of the <code>SplineMeshComponent</code>s are in the right
                        places, but they don't line up quite right.
                    </p>
                    <div class="generic-shrink-container-62p project-image-container generic-maxwidth-500px">
                        <img class="project-image-content elevated-project-content" src="./cursor-misaligned-corner.png"></img>
                    </div>
                    <p>
                        The issue is that the individual splines are basically being used as line segments
                        right now. Each spline is represented with two endpoints and the tangent line at those
                        endpoints, which is not being set. We could easily compute the tangents ourselves,
                        but I decided to use a <code>USplineComponent</code> instead, since it computes
                        all the path's tangents automatically when given its points.
                    </p>

                    <p>
                        Putting it all together gives the following <code>UpdatePath()</code> implementation:
                    </p>

                    <div class="generic-spacer-small"></div>
                    <div class="code-block-container elevated-project-content">
                        <div class="code-block">
                            <div class="code-block-line">bool UGNCursorComponent::UpdatePath(const TArray<FVector>& Points)</div>
                            <div class="code-block-line">{</div>
                            <div class="code-block-line">    check(PathComponent);</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// clear points in SplineComponent and populate it with new path</code-comment></div>
                            <div class="code-block-line">    PathComponent->ClearSplinePoints();</div>
                            <div class="code-block-line">    for (const auto& Point : Points) {</div>
                            <div class="code-block-line">        PathComponent->AddSplinePoint(Point, ESplineCoordinateSpace::Local, false);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    PathComponent->UpdateSpline();</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    return UpdatePathMesh();</div>
                            <div class="code-block-line">}</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">bool UGridNavigatorCursorComponent::UpdatePathMesh()</div>
                            <div class="code-block-line">{</div>
                            <div class="code-block-line">    check(PathComponent);</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    const int NumSegments = PathComponent->GetNumberOfSplineSegments();</div>
                            <div class="code-block-line">    int NumInstantiatedSegmentComponents = PathMeshComponents.Num();</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">    <code-comment>// only runs in the case that NumSegments is more than the available number of mesh components available,</code-comment></div>
                            <div class="code-block-line">    <code-comment>// in which case new mesh components are created and instantiated</code-comment></div>
                            <div class="code-block-line">    for (int i = NumInstantiatedSegmentComponents; i < NumSegments; ++i) {</div>
                            <div class="code-block-line">        FString SplineMeshName = FString::Printf(TEXT("GNCursorComponent.PathMesh.%d"), i);</div>
                            <div class="code-block-line">        auto* NewPathMeshComponent = NewObject<USplineMeshComponent>(this, USplineMeshComponent::StaticClass(), *SplineMeshName);</div>
                            <div class="code-block-line">        check(NewPathMeshComponent);</div>
                            <div class="code-block-line">        </div>
                            <div class="code-block-line">        NewPathMeshComponent->SetMobility(EComponentMobility::Movable);</div>
                            <div class="code-block-line">        NewPathMeshComponent->AttachToComponent(this, FAttachmentTransformRules::KeepWorldTransform);</div>
                            <div class="code-block-line">        NewPathMeshComponent->RegisterComponent();</div>
                            <div class="code-block-line">        NewPathMeshComponent->SetStaticMesh(PathMeshBase);</div>
                            <div class="code-block-line">        NewPathMeshComponent->SetVisibility(true);</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">        PathMeshComponents.Add(NewPathMeshComponent);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    NumInstantiatedSegmentComponents = PathMeshComponents.Num();</div>
                            <div class="code-block-line">    const int NumIterations = FMath::Min(NumSegments, NumInstantiatedSegmentComponents);</div>
                            <div class="code-block-line">    const FVector2D PathMeshScale(PathMeshScaleFactor);</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">    <code-comment>// set up spline mesh components that are already instantiated</code-comment></div>
                            <div class="code-block-line">    for (int i = 0; i < NumIterations; ++i) {</div>
                            <div class="code-block-line">        auto& PathMeshComponent = PathMeshComponents[i];</div>
                            <div class="code-block-line">        check(PathMeshComponent);</div>
                            <div class="code-block-line">        </div>
                            <div class="code-block-line">        const FSplinePoint& P0 = PathComponent->GetSplinePointAt(i, ESplineCoordinateSpace::Local);</div>
                            <div class="code-block-line">        const FSplinePoint& P1 = PathComponent->GetSplinePointAt(i+1, ESplineCoordinateSpace::Local);</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">        PathMeshComponent->SetStartAndEnd(P0.Position, P0.LeaveTangent, P1.Position, P1.ArriveTangent, false);</div>
                            <div class="code-block-line">        PathMeshComponent->SetStartScale(PathMeshScale, false);</div>
                            <div class="code-block-line">        PathMeshComponent->SetEndScale(PathMeshScale, false);</div>
                            <div class="code-block-line">        PathMeshComponent->UpdateMesh();</div>
                            <div class="code-block-line">        PathMeshComponent->SetVisibility(true);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">    <code-comment>// reset excess meshes so they disappear when path has fewer segments than previous</code-comment></div>
                            <div class="code-block-line">    for (int i = NumSegments; i < NumInstantiatedSegmentComponents; ++i) {</div>
                            <div class="code-block-line">        auto& PathMeshComponent = PathMeshComponents[i];</div>
                            <div class="code-block-line">        check(PathMeshComponent);</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">        PathMeshComponent->SetStartPosition(FVector::ZeroVector, false);</div>
                            <div class="code-block-line">        PathMeshComponent->SetEndPosition(FVector::ZeroVector, false);</div>
                            <div class="code-block-line">        PathMeshComponent->UpdateMesh();</div>
                            <div class="code-block-line">        PathMeshComponent->SetVisibility(false);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    return true;</div>
                            <div class="code-block-line">}</div>
                        </div>
                    </div>
                    <div class="generic-spacer-small"></div>

                    <p>
                        With all of this, we have a working cursor. The header code is available
                        <a class="generic-nocolor" target="_blank" href="https://github.com/spencerkarjala/unreal-grid-navigator/blob/main/Source/GridNavigator/Public/GNCursorComponent.h">here</a>,
                        and the implementation code is available
                        <a class="generic-nocolor" target="_blank" href="https://github.com/spencerkarjala/unreal-grid-navigator/blob/main/Source/GridNavigator/Private/GNCursorComponent.cpp">here</a>.
                    </p>

                    <div class="generic-shrink-container-90p project-image-container">
                        <video controls class="project-image-content elevated-project-content">
                            <source src="./cursor-working-demo.mp4">
                        </video>
                    </div>
                </div>

                <div class="generic-spacer-medium"></div>
                <div class="project-page-padding"></div>
                <div class="footer-container">
                    <hr style="width: 50%" />
                    <a id="totop" href="#" class="invisilink">
                        ^
                    </a>
                </div>
            </div>
        </div>
    </body>
</html>
