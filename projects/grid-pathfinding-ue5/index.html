<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Grid Pathfinding in Unreal Engine | skarja.la</title>
        <link rel="stylesheet" href="/styles.css" />
    </head>
    <body id="root-container" class="root-container">
        <div class="document-content-container">
            <div class="project-page-container">
                <div class="header-container">
                    <div class="header-title">
                        <a href="/" class="invisilink">
                            <div class="header-name">
                                skarjala
                            </div>
                        </a>
                        <div class="header-spacer">â€¢</div>
                        <div class="header-contact">
                            spencerkarjala@gmail.com
                        </div>
                    </div>
                    <hr style="width:100%; height:0;" />
                    <div class="nav-container">
                        <a class="nav-item" href="/about/">About</a>
                        <a class="nav-item" href="/projects/">Projects</a>
                    </div>
                </div>

                <div class="project-page-content">
                    <p>
                        Under construction. Sorry!
                    </p>
                    <p>
                        If you'd like to check out the WIP, visit this project's
                        <a class="generic-nocolor" href="https://github.com/spencerkarjala/unreal-grid-navigator" target="_blank">GitHub page</a>.
                    </p>

                    <div class="generic-spacer-medium"></div>

                    <h1>Creating the cursor</h1>
                    <p>
                        For this plugin, I'd like there to be an easy way to hook in a customizable cursor
                        that previews pathfinding results by tracing the path. Something like this:
                    </p>
                    <img style="width: 100%" src="./previewpath-idea.png"></img>
                    <p>
                        Since the path is always attached to the character, it would work as a SceneComponent
                        attached to the PlayerCharacter. Off the top of my head, a user would need to be able to:
                    </p>
                    <ol>
                        <li>Update the cursor destination</li>
                        <li>Set the cursor visibility</li>
                        <li>Customize the look of the cursor</li>
                    </ol>
                    <p>
                        For (1), if we raycast from the player's mouse position, then the hit result can be
                        used as the destination for the cursor. We would also need to pass in the normal
                        vector at that point so the cursor can match the slope of the ground. For now, it's
                        easiest to just let the cursor get the path from the MappingServer.
                    </p>
                    <p>
                        (2) is easy because the built-in <code>SetVisibility()</code> can be used.
                    </p>
                    <p>
                        (3) is more complex, since it's not immediately clear how the cursor is visually
                        represented. A static mesh can be used for the destination component, but what about
                        the path? After reading online for a while and trying a few things, it seems like
                        using <code>SplineMeshComponent</code>s will be quickest. It would be possible to
                        use a <code>ProceduralMeshComponent</code>, but manually building the mesh data
                        sounds time-consuming, and the implementation can be switched later if performance
                        is an issue.
                    </p>
                    <p>
                        That gives the following as the interface:
                    </p>
                    <div class="code-block-container">
                        <div class="code-block-padding"></div>
                        <div class="code-block">
                            <div class="code-block-line">bool UpdateDestination(FVector Destination, FVector Normal);</div>
                            <div class="code-block-line">void SetDestinationMesh(const UStaticMesh* Mesh);</div>
                            <div class="code-block-line">void SetPathMesh(const UStaticMesh* Mesh);</div>
                        </div>
                        <div class="code-block-padding"></div>
                    </div>

                    <div class="generic-spacer-small"></div>

                    <h2>Updating the cursor</h2>

                    <p>
                        At a high level, updating the cursor destination means:
                    </p>
                    <ol>
                        <li>Round the cursor destination to the grid</li>
                        <li>If cursor position hasn't changed, do nothing and return</li>
                        <li>Pathfind to the destination from the player's world position</li>
                        <li>If pathfinding fails, then the point is unreachable, so hide the cursor and return</li>
                        <li>Update <code>SplineMeshComponent</code>s to render the path on-screen</li>
                        <li>Update position of the <code>StaticMeshComponent</code> to the destination</li>
                        <li>Make the cursor visible</li>
                    </ol>
                    <p>
                        An implementation:
                    </p>
                    <div class="code-block-container">
                        <div class="code-block-padding"></div>
                        <div class="code-block">
                            <div class="code-block-line">bool UGNCursorComponent::UpdatePosition(const FVector& WorldDestination, const FVector& DestNormal) {</div>
                            <div class="code-block-line">    FVector DestinationRounded(</div>
                            <div class="code-block-line">        round(WorldDestination.X / 100.0) * 100.0</div>
                            <div class="code-block-line">        round(WorldDestination.Y / 100.0) * 100.0</div>
                            <div class="code-block-line">        WorldDestination.Z</div>
                            <div class="code-block-line">    );</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// don't update cursor if destination location hasn't changed</code-comment></div>
                            <div class="code-block-line">    if ((DestinationRounded - CurrCursorLocation).Length() < 2e-4) {</div>
                            <div class="code-block-line">        return true;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    const FVector& UpDir = FVector::UpVector;</div>
                            <div class="code-block-line">    FVector NormalDir = DestNormal;</div>
                            <div class="code-block-line">    NormalDir.Normalize();</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// hide cursor if floor slope at new dest. is too steep</code-comment></div>
                            <div class="code-block-line">    const double CosOfUpToNormalAngle = FVector::DotProduct(UpDir, NormalDir);</div>
                            <div class="code-block-line">    if (CosOfUpToNormalDir < CosOfMaxInclineAngle) {</div>
                            <div class="code-block-line">        SetVisibility(false);</div>
                            <div class="code-block-line">        return true;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// perform pathfinding</code-comment></div>
                            <div class="code-block-line">    const auto* OwnerActor = GetOwner();</div>
                            <div class="code-block-line">    if (!IsValid(OwnerActor)) {</div>
                            <div class="code-block-line">        UE_LOG(LogGNCursorComopnent, Error, TEXT("Failed to get OwnerActor"));</div>
                            <div class="code-block-line">        return false;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    const TArray&lt;FVector&gt; PathPoints = FMappingServer::GetInstance().FindPath(</div>
                            <div class="code-block-line">        OwnerActor->GetActorLocation(),</div>
                            <div class="code-block-line">        WorldDestination</div>
                            <div class="code-block-line">    );</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// rotate destination mesh if floor slope is too flat</code-comment></div>
                            <div class="code-block-line">    FRotator UpVecToNormalRotation;</div>
                            <div class="code-block-line">    if (CosOfUpToNormalAngle &lt; 1.0 - UE_KINDA_SMALL_NUMBER) {</div>
                            <div class="code-block-line">        UpVecToNormalRotation.Yaw = FMath::RadiansToDegrees(atan2(NormalDir.Y, NormalDir.X));</div>
                            <div class="code-block-line">        UpVecToNormalRotation.Pitch = FMath::RadiansToDegrees(-acos(CosOfUpToNormalAngle));</div>
                            <div class="code-block-line">        DestinationRounded.Z = floor(DestinationRounded.Z / 50.0) * 50.0 + 25.0;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    UpdatePathMesh(PathPoints);</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    const auto LocalCursorDestinationPosition = DestinationRounded;</div>
                            <div class="code-block-line">    DestinationMeshComponent->SetRelativeLocation(LocalCursorDestinationPosition);</div>
                            <div class="code-block-line">    DestinationMeshComponent->SetWorldRotation(UpVecToNormalRotation);</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    CurrCursorLocation = DestinationRounded;</div>
                            <div class="code-block-line">    SetVisibility(true);</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    return true;</div>
                            <div class="code-block-line">}</div>
                        </div>
                        <div class="code-block-padding"></div>
                    </div>

                    <p>a</p>
                    <p>a</p>
                    <p>a</p>

                    <h1>Creating an editor tool</h1>
                    <p>
                        Problem: I'd like editor users to be able to see where their traversable grid is
                        for debugging and to help with understanding how the plugin works. Essentially, if
                        a user clicks on a GNProbe, I'd like to show a wireframe grid along the surface of
                        the level geometry to show what parts are available for navigation. This means:
                    </p>
                    <ol>
                        <li>I would like to show information in the editor when an element is selected</li>
                        <li>This should only happen when the selected element is a GNProbe</li>
                        <li>The information shown in the editor relies on data in the GNProbe</li>
                    </ol>
                    <p>
                        From the
                        <a class="generic-nocolor" href="https://forums.unrealengine.com/t/event-when-actor-selected-in-editor/358904/5">forums</a>,
                        the level editor module has an <code>OnActorSelectionChanged</code> event that can be
                        subscribed to, using:
                    </p>
                    <div class="code-block-container">
                        <div class="code-block-padding"></div>
                        <div class="code-block">
                            <!-- <div class="code-block-line"><code-comment></code-comment></div> -->
                            <div class="code-block-line">FLevelEditorModule& LevelEditor</div>
                            <div class="code-block-line">    = FModuleManager::GetModuleChecked(TEXT("LevelEditor"));</div>
                            <div class="code-block-line">LevelEditor.OnActorSelectionChanged().AddUObject</div>
                            <div class="code-block-line">    .AddUObject(this, &AAAAAAAAAAHandleOnActorSelectionChanged);</div>
                        </div>
                        <div class="code-block-padding"></div>
                    </div>



                    <p>a</p>
                    <p>a</p>
                    <p>a</p>
                    <p>a</p>
                    <p>a</p>
                    <p>a</p>
                    <p>
                        I tried looking online for how to show things in the viewport in Selection Mode (eg.
                        object outlines) but didn't find anything quickly. Instead, I looked through the UE5.3
                        source code and eventually found `/Engine/Source/Editor/LevelEditor/Private/LevelEditor.cpp`,
                        which has the function BroadcastActorSelectionChanged. I placed a breakpoint there and,
                        sure enough, when I clicked on an actor in the editor, the function fired.
                    </p>
                    <p>
                        Following the call stack up leads to FEditorViewportClient::ProcessClickInViewport,
                        which then leads to FEditorModeTools::HandleClick. This function seems to call HandleClick
                        for each of the available editor modes using a template function `ForEachEdMode`. Looking
                        at that function then finally leads to the UEdMode class, which is the base class for all
                        of the editor modes.
                    </p>
                    <p>
                        Ideally, by looking for the derived classes of `UEdMode`, a nice list of all the default
                        UE5 editor modes would appear. Of course, this is not the case, so I went back and dropped
                        a breakpoint on FEditorModeTools::ForEachEdMode. When paused, I could see that the ActiveModes
                        object only had a DefaultEdMode available, which implements the UBaseLegacyWidgetEdMode
                        class, found in LegacyEdModeWidgetHelpers.h. This class is a UEdMode object and also
                        implements the ILegacyEdModeWidgetInterface and ILegacyEdModeViewportInterface, which means
                        it implements the ILegacyEdModeWidgetInterface::HandleClick() function I'm looking for.
                    </p>

                    <img src="./code-flegacyedmodewidgethelper-handleclick.png" style="width:100%">

                </div>
            </div>
            <div class="project-page-padding"></div>
            <div class="footer-container">
                <hr style="width: 50%" />
                <a id="totop" href="#" class="invisilink">
                    ^
                </a>
            </div>
        </div>
    </body>
</html>