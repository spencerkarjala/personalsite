<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Grid Pathfinding in Unreal Engine | skarja.la</title>
        <link rel="stylesheet" href="/styles.css" />
    </head>
    <body id="root-container" class="root-container">
        <div class="document-content-container">
            <div class="project-page-container">
                <div class="header-container">
                    <div class="header-title">
                        <a href="/" class="invisilink">
                            <div class="header-name">
                                skarjala
                            </div>
                        </a>
                        <div class="header-spacer">•</div>
                        <div class="header-contact">
                            spencerkarjala@gmail.com
                        </div>
                    </div>
                    <hr style="width:100%; height:0;" />
                    <div class="nav-container">
                        <a class="nav-item" href="/about/">About</a>
                        <a class="nav-item" href="/projects/">Projects</a>
                    </div>
                </div>

                <div class="project-page-content">
                    <p>
                        This page is a WIP for a module I wrote for an isometric RPG project I've been playing
                        around with. The module exists in its entirety in a much, much larger project, so I'm
                        pulling out the essential features and packaging it as a plugin. Anything shown here is
                        completed and available, but might not make sense in isolation until I've finished the
                        porting process.
                    </p>
                    <p>
                        If you'd like to check out the WIP, visit this project's
                        <a class="generic-nocolor" href="https://github.com/spencerkarjala/unreal-grid-navigator" target="_blank">GitHub page</a>.
                    </p>

                    <div class="generic-spacer-medium"></div>

                    <div class="elevated-container">
                        <div class="elevated-container-label">
                            DEMO
                        </div>
                        <div class="elevated-container-content generic-flex-container-vertical">
                            <video controls class="project-image-content elevated-project-content">
                                <source src="./nav-bounds-working-demo.mp4" type='video/mp4'>
                            </video>
                        </div>
                    </div>

                    <div class="generic-spacer-medium"></div>

                    <h1>Project Overview</h1>
                    <p>
                        The primary goal of this plugin is to implement pathfinding that:
                    </p>
                    <ol>
                        <li>Is aligned to a grid, similar to games like <a class="generic-nocolor" target="_blank" href="https://store.steampowered.com/app/250520/UnderRail/">UnderRail</a>;</li>
                        <li>Has bounds and performs static object avoidance;</li>
                        <li>Is modular, and can be integrated into a project with just a few settings tweaks.</li>
                    </ol>
                    <p>
                        Before talking about system design, it's important to understand how exactly the system will be used.
                        Off the top of my head, these are the main use cases:
                    </p>
                    <ul>
                        <li>From the editor, I want to specify which parts of my static map geometry are navigable</li>
                        <li>From the editor, I want to create links that can teleport the player between different parts of one navigable zone or between multiple navigable zones</li>
                        <li>From the editor, I want to save and load navigation data</li>
                        <li>From blueprint, I want to query for a path between two world positions staying within specified navigable zones</li>
                        <li>From blueprint, I want to dispatch a command for a movement-enabled actor to travel to a new location</li>
                        <li>From blueprint, I want a component to preview navigable paths for player visualization</li>
                    </ul>
                    <p>
                        Most of this is similar to how Unreal's navigation system already works — therefore, most of the
                        work will be around swapping the backend navigation system implementation with something that
                        supports grid-aligned movement.
                    </p>
                    <p>
                        Here's a quick mockup of what I think this looks like from the editor's side:
                    </p>
                    <ul>
                        <li><b>Navigation bounds</b> (<code>NavMeshBoundsVolume</code>) are placed in the world, which specifies to the navigation system which geometry needs navigation data</li>
                        <li><b>Links</b> between navigation bounds are specified that enable player movement between zones</li>
                        <li>If navigation bounds <b>overlap</b>, then pathfinding between them works automatically</li>
                    </ul>
                    <div class="generic-shrink-container-62p project-image-container">
                        <img class="project-image-content elevated-project-content" src="./navboxes.png"></img>
                    </div>

                    <div class="generic-spacer-small"></div>
                    <h1>Exploring Unreal Navigation</h1>
                    <p>
                        To start, I found a <a class="generic-nocolor" target="_blank" href="https://unrealingens.wordpress.com/2018/05/02/overriding-default-ue4-pathfinding-behavior-through-recastnavmesh/">blog post</a>
                        by Nicholas Goldstein that outlines a process for hooking into <code>ARecastNavMesh</code>
                        to provide custom pathfinding without re-compiling the engine. The main notable things
                        about <code>ARecastNavMesh</code> to understand are:
                    </p>
                    <ol>
                        <li>It is an interface for the engine to use <a class="generic-nocolor" target="_blank" href="https://recastnav.com/">Recast</a> navigation</li>
                        <li>The Recast implementation is conveniently hidden behind a <a class="generic-nocolor" target="_blank" href="https://en.cppreference.com/w/cpp/language/pimpl">PImpl</a> pattern</li>
                        <li>The <code>FindPath</code> function is actually a function pointer that can be swapped with a custom implementation</li>
                    </ol>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-600px" src="./recast-nav-mesh-overridables.png"></img>
                        <p class="project-image-subtitle">ARecastNavMesh constructor providing default pathfinding implementations</p>
                    </div>
                    <p>
                        While this gives the insertion point for custom pathfinding logic, it doesn't provide
                        much information on creating and maintaining map data. This is also where the article
                        ends, so we'll have to look more closely at the engine source code next.
                    </p>

                    <div class="generic-spacer-small"></div>
                    <h2>Navigation Bounds</h2>
                    <p>
                        In Unreal Engine, editor users place <code>NavMeshBoundVolume</code>s to specify the
                        areas of geometry that should be navigable. Thankfully, the source code for <code>NavMeshBoundVolume</code>
                        is relatively small — they're mainly used as a proxy to tell the navigation system that
                        its bounds have changed.
                    </p>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./nav-mesh-bounds-volume-post-edit-change-property.png"></img>
                        <p class="project-image-subtitle">PostEditChangeProperty in ANavMeshBoundsVolume.cpp</p>
                    </div>

                    <p>
                        Inside Unreal's navigation system, when <code>OnNavigationBoundsUpdated</code> is called,
                        <code>UNavigationSystemV1</code> queues an <code>FNavigationBoundsUpdateRequest</code> by
                        calling <code>AddNavigationBoundsUpdateRequest</code>. Then, on the next tick, the navigation
                        system services any available navigation bounds update requests.
                    </p>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./navsystem-enqueue-bounds-request.png"></img>
                        <p class="project-image-subtitle">UNavigationSystemV1 enqueueing and servicing a navigation bounds update request</p>
                    </div>

                    <p>
                        To update the navigation bounds, <code>PerformNavigationBoundsUpdate</code> does the following:
                    </p>
                    <ol type="1">
                        <li>For each nav bounds update request, depending on what type of request it is: add, update, or remove the nav bound from the navigation system</li>
                        <li>If any bounds were created, changed, or deleted in the previous step, notify all available <code>ANavigationData</code> instances</li>
                        <li>If navigation building is available, mark any updated nav bounds as 'dirty' to trigger a navigation build</li>
                    </ol>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./navsystem-handle-bounds-update.png"></img>
                        <p class="project-image-subtitle">UNavigationSystemV1 handling navigation bounds update requests (abridged)</p>
                    </div>

                    <p>
                        Steps 2 and 3 of this process are focused on building/rebuilding navigation data through the
                        <code>RebuildDirtyAreas</code> and <code>OnNavigationBoundsChanged</code> functions, which are 
                        both virtual within <code>ANavigationData</code> (the parent class of <code>ARecastNavMesh</code>).
                        A tempting solution is to override these functions, but it looks like Unreal offers a better way
                        forward.
                    </p>

                    <div class="generic-spacer-small"></div>
                    <h2>Building Navigation Data</h2>
                    <p>
                        Interestingly, <code>ARecastNavMesh</code> does not implement either <code>OnNavigationBoundsChanged</code>
                        or <code>RebuildDirtyAreas</code>. This means that it's using <code>ANavigationData</code>'s
                        default implementation, which implies that Unreal must have a way for <code>ARecastNavMesh</code>
                        to define how its builds are implemented. By looking at the base class functions, we can see that this is true:
                    </p>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./navdata-generation-code.png"></img>
                        <p class="project-image-subtitle">ANavigationData handling rebuilds on bounds changes</p>
                    </div>

                    <p>
                        It turns out that the <code>ANavigationData</code> class defines a pointer to an <code>FNavDataGenerator</code>
                        object that implements navigation data builds. This means that Unreal will <i>automatically call nav data builds for us</i>
                        if we implement an <code>FNavDataGenerator</code> and specify it in our custom <code>ARecastNavMesh</code>
                        implementation.
                    </p>
                    <p>
                        The main challenge with building navigation data from <code>FNavDataGenerator</code> is that it
                        will need to do lots of world queries at build time to create the tilemap. The engine code in 
                        <code>FRecastNavMeshGenerator</code> solves this by storing a reference to the <code>ARecastNavMesh</code>
                        that is associated with the generator. That's likely what I will do in the interest of time, but
                        this does mean that the generator class will be pretty tightly coupled to the nav data actor.
                    </p>

                    <div class="generic-spacer-medium"></div>
                    <h1>Creating the Cursor</h1>
                    <p>
                        For this plugin, I'd like there to be an easy way to hook in a customizable cursor
                        that previews pathfinding results by tracing the path. Something like this:
                    </p>
                    <div class="generic-shrink-container-62p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-500px" src="./previewpath-idea.png"></img>
                    </div>
                    <p>
                        Since the path is always attached to the character, it would work as a SceneComponent
                        attached to the PlayerCharacter. Off the top of my head, a user would need to be able to:
                    </p>
                    <ol>
                        <li>Update the cursor destination</li>
                        <li>Set the cursor visibility</li>
                        <li>Customize the look of the cursor</li>
                    </ol>
                    <p>
                        For (1), if we raycast from the player's mouse position, then the hit result can be
                        used as the destination for the cursor. We would also need to pass in the normal
                        vector at that point so the cursor can match the slope of the ground. For now, it's
                        easiest to just let the cursor get the path from the MappingServer.
                    </p>
                    <p>
                        (2) is easy because the built-in <code>SetVisibility()</code> can be used.
                    </p>
                    <p>
                        (3) is more complex, since it's not immediately clear how the cursor is visually
                        represented. A static mesh can be used for the destination component, but what about
                        the path? After reading online for a while and trying a few things, it seems like
                        using <code>SplineMeshComponent</code>s will be quickest. It would be possible to
                        use a <code>ProceduralMeshComponent</code>, but manually building the mesh data
                        sounds time-consuming, and the implementation can be switched later if performance
                        is an issue.
                    </p>
                    <p>
                        That gives the following as the interface:
                    </p>
                    <div class="code-block-container elevated-project-content">
                        <div class="code-block">
                            <div class="code-block-line">void UpdatePosition(const FVector& Destination, const FVector& DestNormal);</div>
                            <div class="code-block-line">void SetDestinationMesh(const UStaticMesh* Mesh);</div>
                            <div class="code-block-line">void SetPathMesh(const UStaticMesh* Mesh);</div>
                        </div>
                    </div>
                    <p>
                        Updating the meshes is easy enough to implement, since it only requires updating
                        the corresponding components and the saved base mesh for the PathMesh.
                    </p>
                    <div class="code-block-container elevated-project-content">
                        <div class="code-block">
                            <div class="code-block-line">void SetDestinationMesh(const UStaticMesh* Mesh)</div>
                            <div class="code-block-line">{</div>
                            <div class="code-block-line">    check(DestinationMesh);</div>
                            <div class="code-block-line">    check(IsValid(Mesh));</div>
                            <div class="code-block-line">    DestinationMesh->SetStaticMesh(Mesh);</div>
                            <div class="code-block-line">}</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">void SetPathMesh(const UStaticMesh* Mesh)</div>
                            <div class="code-block-line">{</div>
                            <div class="code-block-line">    check(IsValid(Mesh));</div>
                            <div class="code-block-line">    PathMeshBase = Mesh;</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// loop over each premade SplineMeshComponent, updating their meshes</code-comment></div>
                            <div class="code-block-line">    for (const auto& PathMeshComponent : PathMeshComponents) {</div>
                            <div class="code-block-line">        check(PathMeshComponent);</div>
                            <div class="code-block-line">        PathMeshComponent->SetStaticMesh(PathMeshBase);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">}</div>
                        </div>
                    </div>

                    <div class="generic-spacer-small"></div>

                    <h2>Updating the cursor</h2>

                    <p>
                        At a high level, updating the cursor destination means:
                    </p>
                    <ol>
                        <li>Round the cursor destination to the grid</li>
                        <li>If cursor position hasn't changed, do nothing and return</li>
                        <li>Pathfind to the destination from the player's world position</li>
                        <li>If pathfinding fails, then the point is unreachable, so hide the cursor and return</li>
                        <li>Update <code>SplineMeshComponent</code>s to render the path on-screen</li>
                        <li>Update position of the <code>StaticMeshComponent</code> to the destination</li>
                        <li>Make the cursor visible</li>
                    </ol>
                    <p>
                        Most of this is hopefully self-explanatory as shown below. Step 5, however, is not
                        trivial, for a couple of reasons.
                    </p>

                    <div class="generic-spacer-small"></div>
                    <div class="code-block-container elevated-project-content">
                        <div class="code-block">
                            <div class="code-block-line">bool UGNCursorComponent::UpdatePosition(const FVector& WorldDestination, const FVector& DestNormal)</div>
                            <div class="code-block-line">{    </div>
                            <div class="code-block-line">    <code-comment>// 1. round destination to configured grid</code-comment></div>
                            <div class="code-block-line">    FVector DestinationRounded(</div>
                            <div class="code-block-line">        round(WorldDestination.X / GridSize) * GridSize</div>
                            <div class="code-block-line">        round(WorldDestination.Y / GridSize) * GridSize</div>
                            <div class="code-block-line">        WorldDestination.Z</div>
                            <div class="code-block-line">    );</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 2. exit early if cursor destination hasn't changed</code-comment></div>
                            <div class="code-block-line">    if ((DestinationRounded - CurrCursorLocation).Length() &lt; 2e-4) {</div>
                            <div class="code-block-line">        return true;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    const FVector& UpDir = FVector::UpVector;</div>
                            <div class="code-block-line">    FVector NormalDir = DestNormal;</div>
                            <div class="code-block-line">    NormalDir.Normalize();</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// hide cursor if floor slope at new dest. is too steep</code-comment></div>
                            <div class="code-block-line">    const double CosOfUpToNormalAngle = FVector::DotProduct(UpDir, NormalDir);</div>
                            <div class="code-block-line">    if (CosOfUpToNormalDir &lt;= CosOfMaxInclineAngle) {</div>
                            <div class="code-block-line">        SetVisibility(false);</div>
                            <div class="code-block-line">        return true;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 3. perform pathfinding</code-comment></div>
                            <div class="code-block-line">    const auto* OwnerActor = GetOwner();</div>
                            <div class="code-block-line">    if (!IsValid(OwnerActor)) {</div>
                            <div class="code-block-line">        UE_LOG(LogGNCursorComopnent, Error, TEXT("Failed to get OwnerActor"));</div>
                            <div class="code-block-line">        return false;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    const TArray&lt;FVector&gt; PathPoints = FMappingServer::GetInstance().FindPath(</div>
                            <div class="code-block-line">        OwnerActor->GetActorLocation(),</div>
                            <div class="code-block-line">        WorldDestination</div>
                            <div class="code-block-line">    );</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 4. hide cursor if destination is not reachable</code-comment></div>
                            <div class="code-block-line">    if (PathPoints.Num() &lt; 2) {</div>
                            <div class="code-block-line">        SetVisibility(false);</div>
                            <div class="code-block-line">        return true;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// rotate destination mesh if floor slope is too flat</code-comment></div>
                            <div class="code-block-line">    FRotator UpVecToNormalRotation;</div>
                            <div class="code-block-line">    if (CosOfUpToNormalAngle &lt; 1.0 - UE_KINDA_SMALL_NUMBER) {</div>
                            <div class="code-block-line">        UpVecToNormalRotation.Yaw = FMath::RadiansToDegrees(atan2(NormalDir.Y, NormalDir.X));</div>
                            <div class="code-block-line">        UpVecToNormalRotation.Pitch = FMath::RadiansToDegrees(-acos(CosOfUpToNormalAngle));</div>
                            <div class="code-block-line">        DestinationRounded.Z = floor(DestinationRounded.Z / 50.0) * 50.0 + 25.0;</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 5. update meshes to display the path</code-comment></div>
                            <div class="code-block-line">    UpdatePath(PathPoints);</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 6. update destination mesh to show final point on path</code-comment></div>
                            <div class="code-block-line">    const auto LocalCursorDestinationPosition = DestinationRounded;</div>
                            <div class="code-block-line">    DestinationMeshComponent->SetRelativeLocation(LocalCursorDestinationPosition);</div>
                            <div class="code-block-line">    DestinationMeshComponent->SetWorldRotation(UpVecToNormalRotation);</div>
                            <div class="code-block-line">    </div>

                            <div class="code-block-line">    <code-comment>// 7. save cursor state and make the cursor visible</code-comment></div>
                            <div class="code-block-line">    CurrCursorLocation = DestinationRounded;</div>
                            <div class="code-block-line">    SetVisibility(true);</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    return true;</div>
                            <div class="code-block-line">}</div>
                        </div>
                    </div>
                    <div class="generic-spacer-small"></div>

                    <p>
                        <b>Problem 1</b>: Because the number of points along the path is variable, the number
                        of splines needed to represent the path is also variable.
                    </p>
                    <p>
                        Specifically, if there are N points along the path, then there are N-1 <code>SplineMeshComponent</code>s
                        needed to display that path. This means that <code>SplineMeshComponent</code>s need to be
                        allocated to, connected to, disconnected from, and deleted from the cursor at runtime,
                        which sounds complicated and messy.
                    </p>
                    <div class="generic-shrink-container-62p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-500px" src="./previewpath-segments-example.png"></img>
                    </div>
                    <p>
                        Instead, a better approach is to pre-allocate a list of <code>SplineMeshComponent</code>s
                        that are shown and hidden at runtime. If the path needs more spline sections, more will
                        be allocated and connected to the cursor, but they will just be added to the pre-allocated
                        list and treated the same as the others.
                    </p>
                    <div class="generic-shrink-container-90p project-image-container">
                        <img class="project-image-content elevated-project-content generic-maxwidth-700px" src="./previewpath-list-spline-idea.png"></img>
                    </div>

                    <p>
                        <b>Problem 2</b>: The ends of the <code>SplineMeshComponent</code>s are in the right
                        places, but they don't line up quite right.
                    </p>
                    <div class="generic-shrink-container-62p project-image-container generic-maxwidth-500px">
                        <img class="project-image-content elevated-project-content" src="./cursor-misaligned-corner.png"></img>
                    </div>
                    <p>
                        The issue is that the individual splines are basically being used as line segments
                        right now. Each spline is represented with two endpoints and the tangent line at those
                        endpoints, which is not being set. We could easily compute the tangents ourselves,
                        but I decided to use a <code>USplineComponent</code> instead, since it computes
                        all the path's tangents automatically when given its points.
                    </p>

                    <p>
                        Putting it all together gives the following <code>UpdatePath()</code> implementation:
                    </p>

                    <div class="generic-spacer-small"></div>
                    <div class="code-block-container elevated-project-content">
                        <div class="code-block">
                            <div class="code-block-line">bool UGNCursorComponent::UpdatePath(const TArray<FVector>& Points)</div>
                            <div class="code-block-line">{</div>
                            <div class="code-block-line">    check(PathComponent);</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    <code-comment>// clear points in SplineComponent and populate it with new path</code-comment></div>
                            <div class="code-block-line">    PathComponent->ClearSplinePoints();</div>
                            <div class="code-block-line">    for (const auto& Point : Points) {</div>
                            <div class="code-block-line">        PathComponent->AddSplinePoint(Point, ESplineCoordinateSpace::Local, false);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    PathComponent->UpdateSpline();</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    return UpdatePathMesh();</div>
                            <div class="code-block-line">}</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">bool UGridNavigatorCursorComponent::UpdatePathMesh()</div>
                            <div class="code-block-line">{</div>
                            <div class="code-block-line">    check(PathComponent);</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    const int NumSegments = PathComponent->GetNumberOfSplineSegments();</div>
                            <div class="code-block-line">    int NumInstantiatedSegmentComponents = PathMeshComponents.Num();</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">    <code-comment>// only runs in the case that NumSegments is more than the available number of mesh components available,</code-comment></div>
                            <div class="code-block-line">    <code-comment>// in which case new mesh components are created and instantiated</code-comment></div>
                            <div class="code-block-line">    for (int i = NumInstantiatedSegmentComponents; i < NumSegments; ++i) {</div>
                            <div class="code-block-line">        FString SplineMeshName = FString::Printf(TEXT("GNCursorComponent.PathMesh.%d"), i);</div>
                            <div class="code-block-line">        auto* NewPathMeshComponent = NewObject<USplineMeshComponent>(this, USplineMeshComponent::StaticClass(), *SplineMeshName);</div>
                            <div class="code-block-line">        check(NewPathMeshComponent);</div>
                            <div class="code-block-line">        </div>
                            <div class="code-block-line">        NewPathMeshComponent->SetMobility(EComponentMobility::Movable);</div>
                            <div class="code-block-line">        NewPathMeshComponent->AttachToComponent(this, FAttachmentTransformRules::KeepWorldTransform);</div>
                            <div class="code-block-line">        NewPathMeshComponent->RegisterComponent();</div>
                            <div class="code-block-line">        NewPathMeshComponent->SetStaticMesh(PathMeshBase);</div>
                            <div class="code-block-line">        NewPathMeshComponent->SetVisibility(true);</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">        PathMeshComponents.Add(NewPathMeshComponent);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    NumInstantiatedSegmentComponents = PathMeshComponents.Num();</div>
                            <div class="code-block-line">    const int NumIterations = FMath::Min(NumSegments, NumInstantiatedSegmentComponents);</div>
                            <div class="code-block-line">    const FVector2D PathMeshScale(PathMeshScaleFactor);</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">    <code-comment>// set up spline mesh components that are already instantiated</code-comment></div>
                            <div class="code-block-line">    for (int i = 0; i < NumIterations; ++i) {</div>
                            <div class="code-block-line">        auto& PathMeshComponent = PathMeshComponents[i];</div>
                            <div class="code-block-line">        check(PathMeshComponent);</div>
                            <div class="code-block-line">        </div>
                            <div class="code-block-line">        const FSplinePoint& P0 = PathComponent->GetSplinePointAt(i, ESplineCoordinateSpace::Local);</div>
                            <div class="code-block-line">        const FSplinePoint& P1 = PathComponent->GetSplinePointAt(i+1, ESplineCoordinateSpace::Local);</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">        PathMeshComponent->SetStartAndEnd(P0.Position, P0.LeaveTangent, P1.Position, P1.ArriveTangent, false);</div>
                            <div class="code-block-line">        PathMeshComponent->SetStartScale(PathMeshScale, false);</div>
                            <div class="code-block-line">        PathMeshComponent->SetEndScale(PathMeshScale, false);</div>
                            <div class="code-block-line">        PathMeshComponent->UpdateMesh();</div>
                            <div class="code-block-line">        PathMeshComponent->SetVisibility(true);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">    <code-comment>// reset excess meshes so they disappear when path has fewer segments than previous</code-comment></div>
                            <div class="code-block-line">    for (int i = NumSegments; i < NumInstantiatedSegmentComponents; ++i) {</div>
                            <div class="code-block-line">        auto& PathMeshComponent = PathMeshComponents[i];</div>
                            <div class="code-block-line">        check(PathMeshComponent);</div>
                            <div class="code-block-line"> </div>
                            <div class="code-block-line">        PathMeshComponent->SetStartPosition(FVector::ZeroVector, false);</div>
                            <div class="code-block-line">        PathMeshComponent->SetEndPosition(FVector::ZeroVector, false);</div>
                            <div class="code-block-line">        PathMeshComponent->UpdateMesh();</div>
                            <div class="code-block-line">        PathMeshComponent->SetVisibility(false);</div>
                            <div class="code-block-line">    }</div>
                            <div class="code-block-line">    </div>
                            <div class="code-block-line">    return true;</div>
                            <div class="code-block-line">}</div>
                        </div>
                    </div>
                    <div class="generic-spacer-small"></div>

                    <p>
                        With all of this, we have a working cursor. The header code is available
                        <a class="generic-nocolor" target="_blank" href="https://github.com/spencerkarjala/unreal-grid-navigator/blob/main/Source/GridNavigator/Public/GNCursorComponent.h">here</a>,
                        and the implementation code is available
                        <a class="generic-nocolor" target="_blank" href="https://github.com/spencerkarjala/unreal-grid-navigator/blob/main/Source/GridNavigator/Private/GNCursorComponent.cpp">here</a>.
                    </p>

                    <div class="generic-shrink-container-90p project-image-container">
                        <video controls class="project-image-content elevated-project-content">
                            <source src="./cursor-working-demo.mp4">
                        </video>
                    </div>
                </div>
            </div>
            <div class="project-page-padding"></div>
            <div class="footer-container">
                <hr style="width: 50%" />
                <a id="totop" href="#" class="invisilink">
                    ^
                </a>
            </div>
        </div>
    </body>
</html>